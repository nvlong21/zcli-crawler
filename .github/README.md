# Crawler

FastAPI project generated by script

This project is built using FastAPI and follows principles inspired by Domain-Driven Design (DDD), Clean Architecture, and uses common patterns like Repository, Unit of Work, and Dependency Injection.

## Features

*   **Core Framework**: FastAPI
*   **Architecture**: DDD-Lite / Clean Architecture Layers (Domain, Application, Infrastructure, Presentation)
*   **API Styles**: REST (FastAPI), gRPC (optional, via `grpcio`)
*   **Database**: SQLAlchemy ORM (Async/Sync support), Alembic for migrations
*   **Dependency Injection**: FastAPI's `Depends` system, centralized in `app/dependencies.py`
*   **Data Validation**: Pydantic
*   **Authentication**: JWT with Passlib for hashing (`python-jose`, `passlib`)
*   **Caching**: Redis or In-Memory cache abstraction (`redis-py`)
*   **Async Support**: Leverages `asyncio` throughout the stack.
*   **Testing**: Pytest with `pytest-asyncio`, `httpx`, `factory-boy`
*   **Linting/Formatting**: Ruff
*   **Type Checking**: MyPy
*   **Containerization**: Docker support (`Dockerfile`)
*   **Task Management**: Makefile for common commands
*   **CI/CD**: Basic GitHub Actions workflow included

## Implemented Features

This project includes the following generated business features:
*   `orders users` (Adjust based on generated features)

## Project Structure

(Generated structure - using ASCII characters)

```
.
+-- app/                  # Core application logic (config, deps, exceptions)
+-- features/             # Business feature modules (domain, app, presentation)
|   `-- <feature_name>/   # Example: users/, orders/
+-- infrastructure/       # Shared technical concerns
|   +-- auth/
|   +-- cache/
|   +-- database/
|   |   `-- models/       # SQLAlchemy models generated per feature
|   +-- external_services/
|   |   `-- clients/
|   +-- grpc/             # .proto definitions and generated code
|   +-- middleware/
|   +-- repositories/     # Repository implementations generated per feature
|   +-- uow/              # Unit of Work
|   `-- utils/
+-- migrations/           # Alembic database migration scripts
|   `-- versions/
+-- presentation/         # FastAPI app setup (main.py), gRPC server
|   +-- api/
|   |   `-- v1/
|   `-- grpc_server.py
+-- tests/                # Unit and integration tests
|   +-- integration/
|   |   `-- <feature_name>/
|   `-- unit/
|       `-- <feature_name>/
+-- .env                  # Local environment variables (DO NOT COMMIT!)
+-- .gitignore            # Git ignore rules
+-- alembic.ini           # Alembic configuration
+-- Dockerfile            # Docker build instructions
+-- Makefile              # Development commands
+-- pyproject.toml        # Project metadata and dependencies (Poetry)
`-- README.md             # This file
```

## Setup and Running

1.  **Prerequisites**:
    *   Python `3.10` (or compatible - check `pyproject.toml`)
    *   Poetry (`pipx install poetry` or `pip install poetry`)
    *   Docker & Docker Compose (optional, for containerized environment)
    *   Database Server (e.g., PostgreSQL - running and accessible)
    *   Redis Server (optional, for caching - running and accessible)
    *   `protoc` compiler and `grpcio-tools` (only if modifying `.proto` files)

2.  **Environment Setup**:
    ```bash
    # Clone the repository (if not already done)
    # git clone ...
    # cd Crawler

    # Create your local environment file if it doesn't exist
    # The generator should create a .env file based on .env.template
    # If missing, copy from template: cp .env.template .env

    # ---> IMPORTANT: Edit the .env file <---
    # Set your DATABASE_URL, SECRET_KEY, cache settings, API keys, etc.
    # Ensure the database name used in DATABASE_URL exists or the user has creation privileges.
    ```

3.  **Install Dependencies**:
    ```bash
    # Recommended: Ensure your virtualenv matches the lock file exactly
    make sync
    # Or, if you prefer install: make install
    ```

4.  **Database Migrations**:
    *   Ensure the database server is running and accessible.
    *   Apply migrations to create tables:
        ```bash
        make migrate
        ```
    *   To create a new migration after changing SQLAlchemy models:
        ```bash
        make makemigrations m="Your descriptive migration message"
        # Review the generated migration script in migrations/versions/
        make migrate
        ```

5.  **Generate gRPC Code** (Only if modifying `.proto` files):
    ```bash
    make generate-grpc
    ```

6.  **Run the Application**:
    *   **Development Mode** (with auto-reload):
        ```bash
        make run
        ```
    *   **Production-like Mode** (multiple workers, no reload):
        ```bash
        make run-prod
        ```

7.  **Access**:
    *   REST API Docs (Swagger UI): `http://localhost:8000/docs` (or the address shown)
    *   REST API Docs (ReDoc): `http://localhost:8000/redoc`
    *   Health Check: `http://localhost:8000/health`
    *   gRPC Server (if enabled): `localhost:50051` (use a gRPC client like `grpcurl`)

## Running with Docker

1.  Build the image:
    ```bash
    make docker-build
    ```
2.  Run the container (ensure `.env` file exists and is configured):
    ```bash
    make docker-run
    ```
3.  View logs:
    ```bash
    make docker-logs
    ```
4.  Stop the container:
    ```bash
    make docker-stop
    ```
    *(Note: For managing dependencies like DB/Redis in Docker, consider using Docker Compose and the corresponding make targets.)*

## Development Tools

*   **Testing**: `make test` or `make test-cov`
*   **Linting**: `make lint`
*   **Formatting**: `make format`
*   **Type Checking**: `make check`
*   **Run all checks**: `make check-all`
## Adding a New Feature Manually (Example: `<new_feature>`)

This guide outlines the steps to manually add a new business feature (e.g., "products", "inventory") following the project's patterns. Replace `<new_feature>` with your actual feature name (lowercase, underscore_separated) and `<NewFeature>` with the PascalCase version.

1.  **Create Directories**:
    *   `features/<new_feature>/`
    *   `features/<new_feature>/app/use_cases/`
    *   `features/<new_feature>/domain/entities/`
    *   `features/<new_feature>/domain/services/` (optional)
    *   `features/<new_feature>/domain/value_objects/` (optional)
    *   `features/<new_feature>/presentation/api/v1/`
    *   `features/<new_feature>/presentation/grpc/` (optional)
    *   `tests/unit/<new_feature>/`
    *   `tests/integration/<new_feature>/`
    *   Create necessary `__init__.py` files within these new directories.
2.  **Domain Layer (`features/<new_feature>/domain/...`)**:
    *   Define the main **Entity** (`entities/<new_feature>.py`) using Pydantic (`class <NewFeature>(BaseModel):`). Include fields, validation (`Field`), and domain logic methods.
    *   (Optional) Define **Value Objects** (`value_objects/...`) for complex attributes with validation or behavior.
    *   (Optional) Define **Domain Services** (`services/...`) if logic involves multiple entities or doesn't fit within a single entity.

3.  **Infrastructure Layer - Database**:
    *   Create the SQLAlchemy **Model** (`infrastructure/database/models/<new_feature>_model.py`) mirroring the entity (`class <NewFeature>(Base):`). Define table name and columns using `Mapped`/`mapped_column`.
    *   Add the import to `infrastructure/database/models/__init__.py`: `from .<new_feature>_model import <NewFeature>`.

4.  **Database Migrations**:
    *   Generate a new migration script: `make makemigrations m="Add <new_feature> table and relationships"`.
    *   Review the generated script in `migrations/versions/`.
    *   Apply the migration: `make migrate`.

5.  **Infrastructure Layer - Repository**:
    *   Create the **Repository Implementation** (`infrastructure/repositories/<new_feature>_repository.py`) inheriting from `BaseRepository` (`class <NewFeature>Repository(BaseRepository[<NewFeature>Model, <NewFeature>Entity]):`).
    *   Implement the required `model_class` property.
    *   Add any custom query methods needed by use cases.
    *   **Register the repository** in `infrastructure/repositories/factory.py`:
        *   Add import: `from features.<new_feature>.domain.entities.<new_feature> import <NewFeature> as <NewFeature>Entity`
        *   Add import: `from infrastructure.repositories.<new_feature>_repository import <NewFeature>Repository`
        *   Add mapping to `_repository_map`: `<NewFeature>Entity: <NewFeature>Repository,`

6.  **Application Layer (`features/<new_feature>/app/use_cases/`)**:
    *   Create **Use Cases** (e.g., `create_<new_feature>.py`, `get_<new_feature>.py`) as classes.
    *   Inject dependencies (Repository Interface, Unit of Work, other services) via the constructor.
    *   Implement the `execute` method to orchestrate domain logic and infrastructure calls (within a UoW context for write operations). Handle application-level exceptions (`NotFoundError`, `ConflictError`, etc.).

7.  **Presentation Layer (`features/<new_feature>/presentation/api/v1/`)**:
    *   Create the **API Endpoint** file (`<new_feature>_api.py`).
    *   Define Pydantic **Schemas** for request bodies (`CreateSchema`, `UpdateSchema`) and responses (`ResponseSchema`).
    *   Create an `APIRouter` instance with a prefix (e.g., `/new_features`) and tags.
    *   Define endpoint functions (`@router.post(...)`, `@router.get(...)`, etc.).
    *   Inject dependencies using FastAPI's `Depends` and `Annotated` (use `get_repo(<NewFeature>Entity)` for the repository, inject UoW).
    *   Instantiate and call the appropriate Use Case in each endpoint function.
    *   Handle exceptions from the Use Case and map them to `HTTPException`.
    *   **Include the router** in `presentation/main.py`:
        *   Add import: `from features.<new_feature>.presentation.api.v1.<new_feature>_api import router as <new_feature>_router`
        *   Add include: `app.include_router(<new_feature>_router)` (inside the main `app` instance definition).
8.  **(Optional) gRPC Layer (`features/<new_feature>/presentation/grpc/`)**:
    *   Define service and messages in a `.proto` file (`infrastructure/grpc/<new_feature>.proto`).
    *   Generate Python code: `make generate-grpc`.
    *   Implement the **Servicer** class inheriting from the generated gRPC base class. Inject dependencies (Use Cases).
    *   **Register the Servicer** in `presentation/grpc_server.py` (add imports and registration tuple).

9.  **Dependencies (`app/dependencies.py`)**:
    *   Usually, using the generic `get_repo(<NewFeature>Entity)` is sufficient.
    *   Define specific dependency providers only if complex setup or different dependency types are needed for this feature.

10. **Tests (`tests/unit/<new_feature>`, `tests/integration/<new_feature>`)**:
    *   Write unit tests for domain logic, use cases (mocking dependencies).
    *   Write integration tests for API endpoints (using `TestClient`), testing the flow through layers (potentially interacting with a test database/cache).

## License

[Specify License Here, e.g., MIT]
